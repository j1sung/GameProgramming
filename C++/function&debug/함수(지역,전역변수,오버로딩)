#include <iostream>
using namespace std;

// 변수 [타입] [변수이름]

// <전역 변수> -> 전역으로 어떤 함수에서도 사용하고 건들여 수치를 변환하고 다 접근이 가능하게 만든 함수이다. -> data 메모리에 저장된다.
int hp = 100;   // 단점으로는 프로젝트에서 규모가 커지면 이 변수를 사용하는 부분이 많기에 어디서 건들여서 오류가 났는지 알기 힘들어 실무에선 잘 사용되지 않는다.
int healing = 10; // 진짜 쓸 수 밖에 없는 상황이 아니면 지역변수를 사용하게 될 것이다.

// <지역 변수> -> 선언된 변수가 있는 함수 내부에서만 사용 가능한 변수 -> STACK 영역에 저장된다.
void TestLocal() 
{ // 정확히는 {} 중괄호 안에서만 영역으로 지정된다.
    int mp;  
    mp = 100;
    {
        int mp;
        mp = 200;
    }
    { // 이렇게 영역을 여러개 만들어서 같은 이름의 지역변수를 한 함수에서도 여러개 만들 순 있다.
        int mp;
        mp = 300;
    }
}

// 함수 [타입] [함수이름](매개변수){} 

// <함수의 오버로딩!>
void Test(int a);
void Test(int a, int b); // 함수 이름이 같아도 매개변수가 타입이 다르거나 갯수가 다르면 다른 함수로 인식한다.
void Test(float a);    // 따라서 제일 맞는 함수를 알아서 선택해 실행시켜주지만 간혹 잘못 실행하는 버그가 존재할 수 있음!
// int Test(int a); -> 반환값의 타입은 달라도 같은 함수로 인식함!!

void Heal1(int a, int b); // 함수 선언부 -> 위에서 코드를 순서대로 읽는데 선언을 미리 해두면 main함수 밑에 함수가 있어도 컴파일 오류가 안뜸
int Heal2(int a, int b);  // C++ 에선 함수를 선언부 + 구현부로 나눠서 작성하는게 일반적이며 나중에 헤더파일, 소스파일 2개로 구성되는 파일로 나뉨 / C#은 하나로 쓰는 차이

void Heal1(int a, int b)
{
    cout << "체력: "<< a+b << endl;
}

int Heal2(int a, int b)
{
    return a + b; // return은 굉장히 강력해서 return문이 나오자 마자 어떤 상황에서든지 함수를 빠져나온다.
}

int main()
{
    Heal1(hp, healing);
}
